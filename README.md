В КАКОЙ ПОСЛЕДОВАТЕЛЬНОСТИ СМОТРЕТЬ ФАЙЛЫ:
1. `make_database.sql` -> `make_database_improved.sql`
2. Миграции из папки `migrations/`
3. Модель Продукта `src/Entity/Product.php`
4. Класс-сервис для Продукта `src/Service/ProductService.php`
5. Собственно, запускающая команда для импорта `src/Command/ImportCommand.php`
--------

1. Во-первых, поменяем sql-скрипт (пункты 1 и 2 из списка выше).
  - snake case используем, т.к. даст меньше проблем, если в будущем придется портировать БД или при использовании других тулзов, т.к. в основном все используют snake case в базах данных
  - поправим имена - уберем дублирования из переменных
  - created_at - более принятое и понятное название вместо dtmAdded
  -  изменяем timestamp на то, чтобы он использовал datetime, чтобы избежать бага [Y2028](https://en.wikipedia.org/wiki/Year_2038_problem) (я сделал небольшой ресерч, и, видимо, до сих пор mysql не решили проблему с TIMESTAMP).
  - latin1 charset тоже нельзя использовать, если у нас в будущем появятся поля в таблице, которые содержат non-english characters, в противном случае будут gibberish characters. В общих случаях, мы должны использовать чарсет, который бы мог хранить в себе больше, чем 1 байт, для символа и более обширный список символов, например, utf8mb4_general_ci,  utf8mb4_unicode_ci или utf8mb4_unicode_520_ci.
  - опустим инициализацию CHARSET в sql-query, т.к. изначально зададим базе, например, utf8mb4_general_ci, а таблица уже сама подхватит нужный charset в соответствующие поля
2. Используем sql-скрипт чтобы описать модель Product (файл Entity/Product.php) - пункт 3.
  - вместо datetime используем datetime_immutable, т.к. datetime немного bug-risky.
  - не забываем также проставить primary и unique key constraints на id и code соответственно
  - добавляем поля stock и price. Внимание на price: доктрина переводит в строку, чтобы избежать проблем с точным счетом float чисел
3. Пишем класс ProductService, который возьмет на себя работу по бизнес-логике (применение правил). В своем методе он будет возвращать массив, в котором еще два массива: с "хорошими" продуктами и "плохими" (пункт 4).

Запуск команды импорта производится через команду: `php bin/console import` (пункт 5).

Additional Considerations:
Также было бы неплохо сохранять в поле created_at, либо в каком-то другом похожем, время занесения продукта в БД по времени универсальному времени UTC.
Для этого в MySQL есть функции, например, если правильно помню, что-то вроде TIMESTAMP_UTC().

Considerations из ворд-документа:
1. Можем написать код (или взять что-то готовое), который бы проверял валидность CSV-файла.
Например, что полей в строках должно быть столько же, сколько и полей в первой строке (хэдер CSV-файла) и ещё, кажется, надо быть внимательным к тому, какие спецсимволы ставятся в окончании строки.
2. Эту функцию выполняют ORM по типу Доктрины.
3. "data encoding issues" - по-хорошему эту проблему надо решать на стороне клиента, т.е. той программы, которая изначально генерирует этот CSV-файл. Мы же, в свою очередь, просто можем задать нормальную кодировку в базе и в PHP не забывать использовать строковые функции только с приставкой mb_.
"line termination problems" - описал в пункте 1.
4. По-хорошему эту проблему тоже надо решать на стороне клиента. Мы, в свою очередь, можем опираться на помощь ORM и MySQL - ORM подскажет на уровне кода, какие типы у нас неправильные, а MySQL подскажет, например, что какие-нибудь уникальные поля дублируются, и, соответственно, MySQL не пропустит такой "ошибочный" продукт в базу.